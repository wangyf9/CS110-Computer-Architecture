exercise1
未初始化
1.(1)simple_fn 是因为使用了未提前声明的t0来初始化声明a0， 所以可以用x0初始化（或删掉，
因为下一步是赋值为1，也可视为初始化过程）


在.globl 声明的函数中，未保存被函数使用过的寄存器的原始值
（2）naive_pow, 则视为function，而s0在最开始是有自己的赋值的，而在该函数中，s0作为一个局部变量，
最后他的值传给a0，最后返回到主程序中，但是此时s0并没有变回原先的值，所以我们需要在进行前提前用stack
存储s0最初的值，在函数结束时，在load回来，保证其值不发生改变
(3)inc_arr，同（2），因为他对s0和s1都进行了了操作，所以我们应该用stack对他们两个进行一个提前的存储保存
以便最后的返回恢复。

2.不适用，它相当于一个函数的内部剩下两部分并不涉及函数的调用，并且beq 和 j 并不会存储ra即当前的地址，并不需要返回。
3.因为在inc_arr_loop中我们又调用了help_fn,并且使用了jal，因为未写return address的存储寄存器位置，默认为ra
因此我们需要在inc_arr中存储ra来返回主函数，因为我们在函数中跳转至下级函数用到了ra.
4.因为cc只能检查在.globl声明的函数中导致的calling convention问题（即主程序中），若其发生在.globl声明的函数
调用中，那么就不会报错，即函数调用函数，函数的嵌套。
exercise2
map 首先需要在stack中存储s0和ra因为在.mian中这两个寄存器都已经使用，所以要caller-saved
因为当前位置未发生改变所以当前的值即lw from s0 因为s0 被赋值为a0 为第一个的地址
然后跳转至 function which we have stored in s1
square完后，我们重新将其存至s0，即产生值的改变...